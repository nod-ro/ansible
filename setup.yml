
- hosts: localhost
  become: yes
  vars_files:
    - environment.yml
  tasks:
    - name: Update and Upgrade System
      apt:
        update_cache: yes
        upgrade: 'yes'

    - name: Install NGINX
      apt:
        name: nginx
        state: latest

    - name: Start and Enable NGINX
      service:
        name: nginx
        state: started
        enabled: true

    - name: Install Certbot and its Nginx plugin
      apt:
        name:
          - certbot
          - python3-certbot-nginx
        state: present

    - name: Deploy Nginx config (HTTP)
      template:
        src: nginx_config_non_https.j2
        dest: /etc/nginx/sites-available/{{ domain_name }}
      notify: Reload NGINX

    - name: Generate and/or install certificate
      shell: >
        certbot certonly --nginx
        -d {{ domain_name }}
        --non-interactive --agree-tos
        --email {{ certbot_admin_email }}
        --dry-run
      register: certbot_output
      ignore_errors: yes

    - name: Log Certbot output
      debug:
        var: certbot_output.stdout_lines

    - name: Install PHP 8.1 and its dependencies
      apt:
        name:
          - php{{ php_version }}-fpm
          - php{{ php_version }}-cli
        state: latest
    - name: Ensure necessary PHP extensions are installed
      apt:
        name:
          - php{{ php_version }}-pdo-mysql
          - php{{ php_version }}-curl
          - php{{ php_version }}-xml
          - php{{ php_version }}-mysqli
          - php{{ php_version }}-zip
          - php{{ php_version }}-soap
          - php{{ php_version }}-mbstring
          - php{{ php_version }}-exif
          - php{{ php_version }}-bcmath
          - php{{ php_version }}-opcache
        state: present

    - name: Generate NGINX Site Configuration
      template:
        src: nginx_config.j2
        dest: "/etc/nginx/sites-available/{{ domain_name }}"
      notify:
        - Reload NGINX

    - name: Enable NGINX Site
      file:
        src: "/etc/nginx/sites-available/{{ domain_name }}"
        dest: "/etc/nginx/sites-enabled/{{ domain_name }}"
        state: link
      notify:
        - Reload NGINX

    - name: Increase pm.max_children in PHP-FPM pool configuration
      lineinfile:
        path: "/etc/php/{{ php_version }}/fpm/pool.d/www.conf"
        regexp: "^pm.max_children ="
        line: "pm.max_children = 100"
        state: present

    - name: Update PHP settings
      lineinfile:
        path: /etc/php/8.1/fpm/php.ini  # Actualizează calea conform configurării tale
        regexp: "^{{ item.key }}"
        line: "{{ item.key }} = {{ item.value }}"
      loop:
        - { key: "memory_limit", value: "2048M" }
        - { key: "upload_max_filesize", value: "128M" }
        - { key: "post_max_size", value: "64M" }
        - { key: "max_input_vars", value: "20000" }
        - { key: "max_input_time", value: "1200" }
        - { key: "default_socket_timeout", value: "1200" }
        - { key: "max_file_uploads", value: "500" }
      notify: Restart php-fpm

    - name: Restart PHP-FPM
      service:
        name: php8.1-fpm
        state: restarted

    - name: Deploy Nginx site configuration
      template:
        src: nginx_config.j2
        dest: /etc/nginx/sites-available/{{ domain_name }}
      notify: Reload NGINX

    - name: Ensure Nginx configuration is enabled
      file:
        src: /etc/nginx/sites-available/{{ domain_name }}
        dest: /etc/nginx/sites-enabled/{{ domain_name }}
        state: link

    - name: Install phpMyAdmin and necessary PHP extensions
      apt:
        name:
          - phpmyadmin
          - php8.1-mbstring
        state: present

    - name: Ensure main website directory exists
      ansible.builtin.file:
        path: /var/www/{{ domain_name }}
        state: directory
        mode: '0755'  # Set the permissions (optional)

    - name: Ensure main tmp directory exists
      ansible.builtin.file:
        path: /var/ansible/tmp
        state: directory
        mode: '0755'  # Set the permissions (optional)

    - name: Ensure main utils directory exists
      ansible.builtin.file:
        path: /var/ansible/utils
        state: directory
        mode: '0755'  # Set the permissions (optional)

    - name: Change ownership of web directory
      become: yes  # to become superuser
      no_log: true
      ansible.builtin.file:
        path: "/var/www/{{ domain_name }}"
        owner: www-data
        group: www-data
        recurse: yes  # to operate recursively

    - name: Download WP-CLI
      command: "curl -o /usr/local/bin/wp https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar"
    - name: Make WP-CLI Executable
      command: "chmod +x /usr/local/bin/wp"
    - name: Check WP-CLI Version
      command: "wp --version --allow-root"
      register: wp_cli_version
    - name: Show WP-CLI Version
      debug:
        var: wp_cli_version.stdout_lines

    - name: Ensure pip is installed
      apt:
        name: python3-pip
        state: present

    - name: Ensure pymysql is installed
      pip:
        name: pymysql
        executable: pip3

    # Check if WordPress is installed
    - name: Check if WordPress is installed
      command: wp core is-installed --path=/var/www/{{domain_name}} --allow-root
      register: wp_is_installed
      ignore_errors: true

    # Download Romanian WordPress core if not installed
    - name: Download Romanian WordPress core
      command: wp core download --locale=ro_RO --path=/var/www/{{domain_name}} --allow-root
      when: wp_is_installed.rc != 0  # Only run when wp core is-installed command fails
      ignore_errors: true

    # Forcefully remove existing wp-config.php if WordPress is not already installed
    - name: Forcefully remove existing wp-config.php
      file:
        path: "/var/www/{{ domain_name }}/wp-config.php"
        state: absent
      when: wp_is_installed.rc != 0

    # Copy WordPress Config if WordPress is not already installed
    - name: Copy WordPress Config
      template:
        src: wp-config.php.j2
        dest: "/var/www/{{ domain_name }}/wp-config.php"
      when: wp_is_installed.rc != 0

    # Install WordPress core if not already installed
    - name: Install WordPress core
      command: wp core install --url={{ domain_name }} --title="{{ domain_title }}" --admin_user={{ wp_user }} --admin_password={{ wp_password }} --admin_email={{ wp_email }} --allow-root --path={{ web_root }}/{{ domain_name }}
      when: wp_is_installed.rc != 0
      ignore_errors: true

    - name: Set WordPress and WooCommerce Language to Romanian
      command: wp site switch-language ro_RO --path={{ web_root }}/{{ domain_name }}
      become: yes
      become_user: www-data  # Replace with your web server user


    - name: Update WordPress permalink structure to use post names
      command: wp option update permalink_structure '/%postname%/'
      become: yes
      become_user: www-data
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"

    - name: Flush rewrite rules
      command: wp rewrite flush
      become: yes
      become_user: www-data
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"

    - name: Set WooCommerce Language to Romanian
      command: wp option update woocommerce_admin_locales 'a:1:{i:0;s:5:"ro_RO";}' --path={{ web_root }}/{{ domain_name }}
      become: yes
      become_user: www-data  # Replace with your web server user

    - name: Install and configure WooCommerce in Romanian
      become: yes
      become_user: root
      command:
        cmd: "{{ item }}"
        chdir: "{{ web_root }}/{{ domain_name }}"
        executable: /bin/bash
      loop:
        - "wp plugin install woocommerce --version=8.2.1 --activate --allow-root --force"
        - "wp language plugin install woocommerce ro_RO --allow-root"
        - "wp language core install ro_RO --allow-root"


    - name: Install and activate WooCommerce public plugins
      command: wp plugin install {{ item.name }} --version={{ item.version }} --path={{ web_root }}/{{ domain_name }} {{ '--activate' if item.activate else '' }} --allow-root --force
      with_items: "{{ public_plugins }}"

    - name: Ensure wp-content permissions are set correctly
      file:
        path: /var/www/{{ domain_name }}/wp-content
        state: directory
        mode: '0755'

    - name: Ensure wp-content/upgrade permissions are set correctly
      file:
        path: /var/www/{{ domain_name }}/wp-content/upgrade
        state: directory
        mode: '0755'

    - name: Ensure wp-content ownership is correct
      file:
        path: /var/www/{{ domain_name }}/wp-content
        state: directory
        owner: www-data
        group: www-data
        recurse: yes

#    - name: Ensure /var/ansible/keys directory exists
#      file:
#        path: "/var/ansible/keys"
#        state: directory
#        mode: '0700'

#    - name: Check if SSH key named 'ansible' already exists in /var/ansible/keys
#      stat:
#        path: "/var/ansible/keys/ansible"
#      register: ssh_key

#    - name: Generate SSH key named 'ansible' if it doesn't exist in /var/ansible/keys
#      command: ssh-keygen -t rsa -b 4096 -f /var/ansible/keys/ansible -N ""
#      when: not ssh_key.stat.exists

#    - name: Get the content of the generated SSH public key named 'ansible'
#      command: cat /var/ansible/keys/ansible.pub
#      register: ssh_public_key
#      changed_when: false

#    - name: Display the public SSH key
#      debug:
#        msg: "{{ ssh_public_key.stdout }}"

    - name: Start ssh-agent
      shell: ssh-agent
      register: ssh_agent_info
      changed_when: false

    - name: Set environment variables for ssh-agent
      set_fact:
        ssh_agent_socket: "{{ ssh_agent_info.stdout_lines[0].split(';')[0].split('=')[1] }}"
        ssh_agent_pid: "{{ ssh_agent_info.stdout_lines[1].split(';')[0].split('=')[1] }}"

#    - name: Ensure private key has correct permissions
#      ansible.builtin.file:
#        path: /var/ansible/keys/ansible
#        mode: '0600'
#        owner: root
#        group: root
#      become: yes

#    - name: Ensure keys directory has correct permissions
#      ansible.builtin.file:
#        path: /var/ansible/keys
#        mode: '0700'
#        owner: root
#        group: root
#        state: directory
#      become: yes

#    - name: Add SSH key to ssh-agent
#      ansible.builtin.shell: ssh-add /var/ansible/keys/ansible
#      environment:
#        SSH_AUTH_SOCK: "{{ ssh_agent_socket }}"
#        SSH_AGENT_PID: "{{ ssh_agent_pid }}"
#      become: yes
#      become_user: root  # or another user if needed
#      ignore_errors: true

    - name: Test SSH connection to GitHub
      command: ssh -T git@github.com
      register: github_connection
      ignore_errors: true
      environment:
        SSH_AUTH_SOCK: "{{ ssh_agent_socket }}"
        SSH_AGENT_PID: "{{ ssh_agent_pid }}"
      failed_when: github_connection.rc != 1  # expecting an exit code of 1 for successful authentication

    - name: Display SSH connection result
      debug:
        var: github_connection

    - name: Download WP-CLI
      get_url:
        url: "https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar"
        dest: "/tmp/wp-cli.phar"
        mode: '0755'

    - name: Move WP-CLI to global path
      copy:
        src: "/tmp/wp-cli.phar"
        dest: "/usr/local/bin/wp"
        mode: '0755'

    - name: Ensure WP-CLI is executable
      file:
        path: "/usr/local/bin/wp"
        mode: '0755'

    - name: Ensure Destination Directory Exists as /var/www/<domain_name>
      file:
        path: "/var/www/{{ domain_name }}"
        state: directory
        owner: www-data  # adjust the owner as per your setup
        group: www-data  # adjust the group as per your setup
        mode: '0755'     # adjust the permissions as per your setup

    #    - name: Extract WordPress Directly to Domain Root
    #      unarchive:
    #        src: "/tmp/wordpress.tar.gz"
    #        dest: "/var/www/{{ domain_name }}"
    #        remote_src: yes
    #        extra_opts: [--strip-components=1]  # Exclude the wordpress/ directory in archive
    #        creates: "/var/www/{{ domain_name }}/wp-config-sample.php"  # Identify WordPress extraction by a specific file

    - name: Ensure git is installed
      apt:
        name: git
        state: present

    - name: Ensure plugins directory exists with correct permissions
      file:
        path: "{{ web_root }}/{{ domain_name }}/wp-content/plugins/{{ item.name }}"
        state: directory
        owner: root  # Replace with your web user, possibly www-data
        group: root  # Replace with your web group, possibly www-data
        mode: '0755'
      loop: "{{ plugins }}"
      become: yes  # Use sudo to ensure permissions

    - name: Install specific version of WooCommerce
      command: wp plugin install woocommerce --version=5.5.1 --allow-root --activate
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"

    - name: Check if plugin directories are not empty
      find:
        paths: "{{ web_root }}/{{ domain_name }}/wp-content/plugins/{{ item.name }}"
        file_type: any
      register: plugin_directory_contents
      loop: "{{ plugins }}"

    - name: Clone the plugin repositories from private repos only if directory is empty
      git:
        repo: "{{ item.item.repo }}"
        dest: "{{ web_root }}/{{ domain_name }}/wp-content/plugins/{{ item.item.name }}"
        force: yes
        version: "{{ item.item.version }}"
        accept_hostkey: yes
      when: item.files | length == 0
      loop: "{{ plugin_directory_contents.results }}"
      become: yes
      become_user: root
      ignore_errors: yes
      environment:
        SSH_AUTH_SOCK: "{{ ssh_agent_socket }}"
        SSH_AGENT_PID: "{{ ssh_agent_pid }}"

    - name: Activate plugins where "activate" property is true
      command: wp plugin activate {{ item.name }} --allow-root
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"
      when: item.activate
      loop: "{{ plugins }}"
      become: yes
      become_user: root

    - name: Check if plugin directory exists and is empty
      find:
        paths: "/var/www/{{domain_name}}/wp-content/plugins/{{ item.slug }}"
        file_type: directory
      register: plugin_directory
      with_items: "{{ external_plugins }}"

    - name: Install and activate external theme's plugins only if directory is empty
      command: "wp plugin install {{ item.url }} --version={{ item.version }} --activate --path=/var/www/{{domain_name}} --allow-root"
      when:
        - "plugin_directory.results[0]['matched'] == 0 or plugin_directory.results[0]['files'] | length == 0"
      with_items: "{{ external_plugins }}"

    - name: Check if theme directories exist
      stat:
        path: "{{ web_root }}/{{ domain_name }}/wp-content/themes/{{ item.name }}"
      register: theme_directory_checks
      loop: "{{ themes }}"

    - name: Clone the themes repositories from private repos only if directory doesn't exist
      git:
        repo: "{{ item.item.repo }}"
        dest: "{{ web_root }}/{{ domain_name }}/wp-content/themes/{{ item.item.name }}"
        force: yes
        version: "{{ item.item.version }}"
        accept_hostkey: yes
      when: not item.stat.exists
      loop: "{{ theme_directory_checks.results }}"
      become: yes
      become_user: root
      ignore_errors: yes
      environment:
        SSH_AUTH_SOCK: "{{ ssh_agent_socket }}"
        SSH_AGENT_PID: "{{ ssh_agent_pid }}"

    - name: Switch to 'nod-electro-theme-child' theme
      command: wp theme activate nod-electro-theme-child --path={{ web_root }}/{{ domain_name }} --allow-root
      become: yes
      become_user: root

    - name: Ensure OpenSSL is installed
      apt:
        name: openssl
        state: present

    - name: Creating logs directory
      file:
        path: "{{ web_root }}/{{ domain_name }}/wp-content/logs"
        state: directory

    - name: Creates NOD Connector logs directory
      file:
        path: "{{ web_root }}/{{ domain_name }}/wp-content/logs/nod-connector"
        state: directory

    - name: Creates lockers directory
      file:
        path: "{{ web_root }}/{{ domain_name }}/wp-content/logs/lockers"
        state: directory

    - name: Creates NOD Connector logs orders directory
      file:
        path: "{{ web_root }}/{{ domain_name }}/wp-content/logs/nod-connector/orders"
        state: directory

    - name: Creates NOD Connector logs orders directory
      file:
        path: "{{ web_root }}/{{ domain_name }}/wp-content/logs/nod-connector/orders/send_to_nod"
        state: directory

    - name: Ensure wget is installed
      ansible.builtin.package:
        name: wget
        state: present

    - name: Ensure WordPress wp-cron is triggered regularly
      ansible.builtin.cron:
        name: "Trigger WordPress wp-cron"
        minute: "*"
        user: "root"
        job: "wget -qO- http://{{ domain_name }}/wp-cron.php &> /dev/null"

    - name: Change ownership of web directory
      become: yes  # to become superuser
      no_log: true
      ansible.builtin.file:
        path: "/var/www/{{ domain_name }}"
        owner: www-data
        group: www-data
        recurse: yes  # to operate recursively

    - name: Set directory permissions
      become: yes
      shell: "find /var/www/{{ domain_name }}/ -type d -exec chmod 755 {} \\;"

    - name: Set file permissions
      become: yes
      shell: "find /var/www/{{ domain_name }}/ -type f -exec chmod 644 {} \\;"

    - name: Change owner of files
      become: yes
      shell: "chown -R www-data:www-data /var/www/{{ domain_name }}"

    - name: Ensure UFW is installed
      apt:
        name: ufw
        state: present

    - name: Ensure UFW is enabled
      ufw:
        state: enabled

    - name: Allow HTTP traffic
      ufw:
        rule: allow
        port: "80"
        proto: tcp

    - name: Allow HTTPS traffic
      ufw:
        rule: allow
        port: "443"
        proto: tcp

    - name: Allow Nginx Full
      ufw:
        rule: allow
        name: 'Nginx Full'

    - name: Allow SSH traffic
      ufw:
        rule: allow
        port: "22"
        proto: tcp

    - name: Update admin password in database
      mysql_query:
        login_host: "{{ db_host }}"
        login_user: "{{ db_user }}"
        login_password: "{{ db_password }}"
        login_db: "{{ db_name }}"
        query: "UPDATE wp_users SET user_pass = MD5('{{ wp_password }}') WHERE user_login = 'admin';"
    #      no_log: true

    - name: Get Home Page ID
      command: "wp post list --post_type=page --name=home --field=ID --format=ids --allow-root --path={{ web_root }}/{{ domain_name }} "
      register: home_page_id_result
      tags:
        - pages

    - name: Set Home Page ID as a variable for later use
      set_fact:
        home_page_id: "{{ home_page_id_result.stdout }}"
      tags:
        - pages

    - name: Create PHP script for updating WordPress option
      template:
        src: update_option.php.j2
        dest: "/var/ansible/tmp/update_option.php"

    - name: Update WordPress Options
      command:
        argv:
          - php
          - "/var/ansible/tmp/update_option.php"
          - "{{ item.option }}"
          - "{{ item.value }}"
      loop:
        # Sync NOC CONNECTOR API
        - { option: "nod_api_url", value: "{{ nod_api_url }}" }
        - { option: "nod_api_user", value: "{{ nod_api_user }}" }
        - { option: "nod_api_key", value: "{{ nod_api_key }}" }

        # Sync azure variables
        - { option: "azure_storage_use_for_default_upload", value: "{{ azure_storage_use_for_default_upload }}" }
        - { option: "microsoft_azure_account_name", value: "{{ microsoft_azure_account_name }}" }
        - { option: "microsoft_azure_account_key", value: "{{ microsoft_azure_account_key }}" }
        - { option: "microsoft_azure_container", value: "{{ microsoft_azure_container }}" }
        - { option: "azure_storage_account_name", value: "{{ azure_storage_account_name }}" }
        - { option: "azure_storage_account_primary_access_key", value: "{{ azure_storage_account_primary_access_key }}" }
        - { option: "default_azure_storage_account_container_name", value: "{{ default_azure_storage_account_container_name }}" }
        - { option: "azure_browse_cache_results", value: "{{ azure_browse_cache_results }}" }
        - { option: "azure_cache_control", value: "{{ azure_cache_control }}" }

        # Set homepage
        - { option: "show_on_front", value: "page" }
        - { option: "page_on_front", value: "{{ home_page_id }}" }

        # Update smartbill_password shown in NC & NE
        - { option: "smartbill_password", value: "{{ smartbill_options.smartbill_password }}" }

        # NOD CONNECTOR SHOP SETTINGS
        - { option: "nod_default_product_status", value: "publish" }
        - { option: "nod_image_update_strategy", value: "nod_images_first_set_only" }
        - { option: "nod_deleted_product_status", value: "delete" }
        - { option: "nod_import_sync_time", value: "4:00:00" }
        - { option: "nod_prices_update_time", value: "5:00:00" }
        - { option: "nod_prices_update_time_2", value: "15:00:00" }
        - { option: "nod_round_final_prices", value: "yes" }
        - { option: "nod_import_special_prices", value: "yes" }
        - { option: "nod_adaos_general", value: "10" }
        - { option: "nod_order_sending_mode_bacs", value: "manual" }
        - { option: "nod_order_sending_mode_cheque", value: "manual" }
        - { option: "nod_order_sending_mode_cod", value: "manual" }
        - { option: "nod_order_sending_mode_netopiapayments", value: "manual" }
        - { option: "nod_settings_debug_level", value: "200" }

        # Woocommerce default settings
        - { option: "woocommerce_store_address", value: "{{customer_support_address}}" }
        - { option: "woocommerce_store_city", value: "{{customer_city}}" }
        - { option: "woocommerce_store_postcode", value: "{{customer_zip}}" }
        - { option: "woocommerce_allowed_countries", value: "specific" }
        - { option: "woocommerce_specific_allowed_countries", value: 'a:1:{i:0;s:2:"RO";}' }
        - { option: "woocommerce_specific_ship_to_countries", value: 'a:1:{i:0;s:2:"RO";}' }
        - { option: "woocommerce_ship_to_countries", value: "specific" }
        - { option: "woocommerce_currency", value: "RON" }
        - { option: "woocommerce_currency_pos", value: "right" }
        - { option: "woocommerce_price_thousand_sep", value: "." }
        - { option: "woocommerce_price_decimal_sep", value: "," }
        - { option: "woocommerce_price_num_decimals", value: "2" }

        # Random
        - { option: "nod_saas_mentenance_status", value: "disabled" }
      become: yes
      become_user: www-data
      tags:
        - options
        - pages
        - woocommerce

    ### GENERATING STATIC PAGES BASED ON THE DEFINED "pages" variable
    - name: Check if page with slug exists
      command: sudo -u www-data wp post list --post_type=page --field=post_name --path="{{ web_root }}/{{ domain_name }}"
      register: existing_pages
      changed_when: false  # This command just checks for existing pages, it doesn't change anything

    - name: Render page content from template
      template:
        src: "pages/{{ item.slug }}.j2"
        dest: "/tmp/{{ item.slug }}.txt"
      become: yes
      become_method: sudo
      become_user: www-data
      loop: "{{ pages }}"
      when: "item.slug not in existing_pages.stdout_lines"

    - name: Create a page in WordPress from rendered content
      command: sudo -u www-data wp post create --post_type=page --post_status=publish --post_title='{{ item.title }}' --post_name='{{ item.slug }}' --path="{{ web_root }}/{{ domain_name }}" /tmp/{{ item.slug }}.txt
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"
      loop: "{{ pages }}"
      when: "item.slug not in existing_pages.stdout_lines"

    - name: Cleanup temporary content file
      file:
        path: "/tmp/{{ item.slug }}.txt"
        state: absent
      become: yes
      become_method: sudo
      become_user: www-data
      loop: "{{ pages }}"
      when: "item.slug not in existing_pages.stdout_lines"

    ## Handling Electro options
    - name: Setting the serialised electro_option string
      template:
        src: serialize_electro_options.php.j2  # Modify this path if needed
        dest: "/var/ansible/utils/serialize_electro_options.php"


    - name: Convert JSON to PHP serialized string and update WP option electro_options
      command: php /var/ansible/utils/serialize_electro_options.php
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"

    - name: Cleanup - Remove the temporary PHP script
      file:
        path: "/var/ansible/utils/serialize_electro_options.php"
        state: absent

    ## Handling Smartbill options
    - name: Setting the serialised electro_option string
      template:
        src: serialize_smartbill_options.php.j2  # Modify this path if needed
        dest: "/var/ansible/utils/serialize_smartbill_options.php"


    - name: Convert JSON to PHP serialized string and update WP option electro_options
      command: php /var/ansible/utils/serialize_smartbill_options.php
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"

    - name: Cleanup - Remove the temporary PHP script
      file:
        path: "/var/ansible/utils/serialize_smartbill_options.php"
        state: absent

# MENUS
    - name: Loop over each menu
      set_fact:
        current_menu: "{{ item }}"
      loop: "{{ menus }}"
      tags:
        - menus

    - name: Get list of existing menus
      command: wp menu list --fields=name --format=csv --allow-root
      register: menu_list
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"
      tags:
        - menus

    - name: Check if menu exists
      set_fact:
        menu_exists: "{{ current_menu.name in menu_list.stdout }}"
      when: menu_list.stdout is defined
      tags:
        - menus

    - name: Create menu if it doesn't exist
      command: wp menu create "{{ current_menu.name }}" --allow-root
      when: not menu_exists
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"
      tags:
        - menus

    - name: Assign the menu to the location
      command: wp menu location assign "{{ current_menu.name }}" "{{ current_menu.location }}" --allow-root
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"
      when: current_menu.location is defined
      tags:
        - menus

    - name: Loop over each menu item
      set_fact:
        current_menu_item: "{{ item }}"
      loop: "{{ current_menu.items }}"
      tags:
        - menus

    - name: Add pages to the menu
      command: "wp post list --post_type=page --field=ID --name={{ current_menu_item.name }} --allow-root"
      register: post_id_result
      when: current_menu_item.type == 'page'
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"
      tags:
        - menus

    - name: Add page to menu
      command: "wp menu item add-post '{{ current_menu.name }}' {{ post_id_result.stdout }} --allow-root"
      when:
        - current_menu_item.type == 'page'
        - post_id_result.stdout | length > 0
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"
      tags:
        - menus

    - name: Add custom link to menu
      command: "wp menu item add-custom '{{ current_menu.name }}' '{{ current_menu_item.title }}' '{{ current_menu_item.url }}' --allow-root"
      when: current_menu_item.type == 'custom'
      args:
        chdir: "{{ web_root }}/{{ domain_name }}"
      tags:
        - menus
  handlers:
    - name: Reload NGINX
      service:
        name: nginx
        state: reloaded
